%\VignetteIndexEntry{gnmOverview}
%\VignetteDepends{gtools}
%\VignetteKeywords{Generalized Nonlinear Models}
%\VignettePackage{gnm}

\documentclass[a4paper]{article}

\usepackage{Sweave}
\usepackage{alltt}
\usepackage{amsmath}
%\usepackage{times}
%\usepackage[scaled]{couriers}
\usepackage{txfonts} % Times, with Belleek math font and txtt for monospaced
\usepackage{booktabs}
\usepackage[round,authoryear]{natbib}
\usepackage[left=2cm,top=3cm,nohead]{geometry}
\usepackage{hyperref}
\usepackage{moreverb}

\setkeys{Gin}{width=0.6\textwidth}

%% The next few definitions from "Writing Vignettes for Bioconductor Packages"
%% by R Gentleman
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\textit{#1}}}
\newcommand{\Rfunarg}[1]{{\textit{#1}}}

\newcommand\twiddle{{\char'176}}

%\setlength{\oddsidemargin}{0.5in}
%\setlength{\evensidemargin}{0.5in}
%\setlength{\textwidth}{5.5in}

\title{Generalized nonlinear models in R: an overview of the
\textbf{\Rpackage{gnm}} package}

\author{Heather Turner and David Firth\footnote{
This work was supported by the Economic and Social Research Council (UK)
through a Professorial Fellowship.}\\
\emph{University of Warwick, UK}
}

\date{For \Rpackage{gnm} version \Sexpr{packageDescription("gnm")[["Version"]]} , \Sexpr{Sys.Date()}}

\begin{document}
\maketitle

{\small
 \tableofcontents
}

\section{Introduction}


The \Rpackage{gnm} package provides facilities for fitting
\emph{generalized nonlinear models}, i.e., regression models in which the
link-transformed mean is described as a sum of predictor terms, some of
which may be non-linear in the unknown parameters.  Linear and generalized
linear models,
as handled by the \Rfunction{lm} and \Rfunction{glm} functions in R, are
included in the class
of generalized nonlinear models, as the special case in which there is no
nonlinear term.

This document gives an extended overview of the \Rpackage{gnm} package, with
some examples of applications.  The primary package documentation in the
form of standard help pages, as viewed in R by, for example, \texttt{?gnm} or
\texttt{help(gnm)}, is supplemented rather than replaced by the present
document.

We begin below with a preliminary note (Section \ref{glms}) on ways in which
the \Rpackage{gnm} package extends R's facilities for specifying, fitting
and working with generalized \emph{linear} models.  Then (Section
\ref{nonlinear} onwards) the facilities for nonlinear terms are introduced,
explained and exemplified.

The \Rpackage{gnm} package is installed in the standard way for CRAN packages,
for example by using \Rfunction{install.packages}.  Once installed, the
package is loaded into an R session by
<<Load_gnm>>=
library(gnm)
@

\section{Generalized Linear Models}
\label{glms}

\subsection{Preamble}

Central to the facilities provided by the \Rpackage{gnm} package is the
model-fitting function \Rfunction{gnm}, which interprets a model formula
and returns a model object.  The user interface of \Rfunction{gnm} is patterned
after \Rfunction{glm} (which is included in R's standard \Rpackage{stats}
package), and indeed
\Rfunction{gnm} can be viewed as a replacement for
\Rfunction{glm} for specifying and fitting generalized linear models.
In general there is no reason to prefer \Rfunction{gnm} to \Rfunction{glm} for
fitting generalized linear models, except perhaps when the model involves a
large number of incidental parameters which are treatable
by \Rfunction{gnm}'s \emph{eliminate} mechanism (see Section \ref{eliminate}).

While the main purpose of the \Rpackage{gnm} package is to extend the class of
models to include nonlinear terms, some of the new functions and methods
can be used also with the familiar \Rfunction{lm} and \Rfunction{glm}
model-fitting functions.  These are: three new data-manipulation functions
\Rfunction{Diag}, \Rfunction{Symm} and \Rfunction{Topo}, for setting up structured interactions between factors; a new \Rclass{family} function,
\Rfunction{wedderburn},
for modelling a response variable in $[0,1]$ with the variance function
$V(\mu) = \mu^2(1-\mu)^2$ as in \citet{Wedd74};
and a new generic function \Rfunction{termPredictors} which
extracts the contribution of each term to the predictor from a fitted model
object.  These functions are briefly introduced here, before we move on to
nonlinear models in Section \ref{nonlinear}.

\subsection{\Rfunction{Diag} and \Rfunction{Symm}}

When dealing with \emph{homologous} factors, that is, categorical variables
whose levels are the same, statistical models often involve structured
interaction terms which exploit the inherent symmetry.  The functions
\Rfunction{Diag} and \Rfunction{Symm} facilitate the specification of such
structured interactions.

As a simple example of their use, consider the log-linear models of
\emph{quasi-independence}, \emph{quasi-symmetry} and \emph{symmetry}
for a square contingency table.  \citet{Agre02}, Section 10.4, gives data on
migration between regions of the USA between 1980 and 1985:
<<migrationData>>=
count <- c(11607,   100,   366,   124,
              87, 13677,   515,   302,
             172,   225, 17819,   270,
              63,   176,   286, 10192 )
region <- c("NE", "MW", "S", "W")
row <-  gl(4, 4, labels = region)
col <-  gl(4, 1, length = 16, labels = region)
@
The comparison of models reported by Agresti can be achieved as follows:
<<squareTableModels>>=
independence <- glm(count ~ row + col, family = poisson)
quasi.indep <- glm(count ~ row + col + Diag(row, col), family = poisson)
symmetry <- glm(count ~ Symm(row, col), family = poisson)
quasi.symm <- glm(count ~ row + col + Symm(row, col), family = poisson)
comparison1 <- anova(independence, quasi.indep, quasi.symm)
print(comparison1, digits = 7)
comparison2 <- anova(symmetry, quasi.symm)
print(comparison2)
@

The \Rfunction{Diag} and \Rfunction{Symm} functions also generalize the notions
of diagonal and symmetric interaction to cover situations involving more than
two homologous factors.

\subsection{\Rfunction{Topo}}

More general structured interactions than those provided by \Rfunction{Diag}
and \Rfunction{Symm} can be specified using the function \Rfunction{Topo}.
(The name of this function is short for `topological interaction',
which is the nomenclature
often used in sociology for factor interactions with structure derived from
subject-matter theory.)

The \Rfunction{Topo} function operates on any number ($k$, say)
of input factors, and
requires an argument named \Rfunarg{spec} which must be an array of
dimension $L_1 \times \ldots \times L_k$, where $L_i$ is the number of
levels for the $i$th factor.  The \Rfunarg{spec} argument specifies
the interaction level corresponding to every possible combination of
the input factors, and the result is a new factor representing the specified
interaction.

As an example, consider fitting the `log-multiplicative layer effects' models
described in \citet{Xie92}.  The data are 7 by 7 versions of social mobility
tables from \citet{Erik82}:
<<EriksonData>>=
data(erikson)
### Collapse to 7 by 7 table as in Erikson et al. (1982)
erikson <- as.data.frame(erikson)
lvl <- levels(erikson$origin)
levels(erikson$origin) <- levels(erikson$destination) <-
    c(rep(paste(lvl[1:2], collapse = " + "), 2), lvl[3],
      rep(paste(lvl[4:5], collapse = " + "), 2), lvl[6:9])
erikson <- xtabs(Freq ~ origin + destination + country, data = erikson)
@
From sociological theory --- for which see \citet{Erik82} or \citet{Xie92} ---
the log-linear interaction between origin and destination is assumed to have
a particular structure:
\newpage
\begin{verbatim}
> levelMatrix <- matrix(c(2, 3, 4, 6, 5, 6, 6,
+                         3, 3, 4, 6, 4, 5, 6,
+                         4, 4, 2, 5, 5, 5, 5,
+                         6, 6, 5, 1, 6, 5, 2,
+                         4, 4, 5, 6, 3, 4, 5,
+                         5, 4, 5, 5, 3, 3, 5,
+                         6, 6, 5, 3, 5, 4, 1), 7, 7, byrow = TRUE)
\end{verbatim}
The models of table 3 of \citet{Xie92} can now be fitted as follows:
\begin{verbatim}
> ## Null association between origin and destination
> nullModel <- gnm(Freq ~ country:origin + country:destination,
+                  family = poisson, data = erikson)
Running main iterations.
Done
> ## Interaction specified by levelMatrix, common to all countries
> commonTopo <- update(nullModel, ~ . +
+                      Topo(origin, destination, spec = levelMatrix))
Running main iterations.
Done
> ## Interaction specified by levelMatrix, different multiplier for each country
> multTopo <- update(nullModel, ~ . + Mult(country, Topo(origin, destination,
+                                       spec = levelMatrix)))
Running start-up iterations..
Running main iterations.......
Done
> ## Interaction specified by levelMatrix, different effects for each country
> separateTopo <- update(nullModel, ~ . +
+                        country:Topo(origin, destination, spec = levelMatrix))
Running main iterations.
Done
>
> anova(nullModel, commonTopo, multTopo, separateTopo)
Analysis of Deviance Table

Model 1: Freq ~ country:origin + country:destination
Model 2: Freq ~ Topo(origin, destination, spec = levelMatrix) + country:origin +
    country:destination
Model 3: Freq ~ Mult(country, Topo(origin, destination, spec = levelMatrix)) +
    country:origin + country:destination
Model 4: Freq ~ country:origin + country:destination + country:Topo(origin,
    destination, spec = levelMatrix)
  Resid. Df Resid. Dev  Df Deviance
1       108     4860.0
2       103      244.3   5   4615.7
3       101      216.4   2     28.0
4        93      208.5   8      7.9
\end{verbatim}
Here we have used \Rfunction{gnm} to fit all of these log-link models; the
first, second and fourth are log-linear and could equally well have been fitted
using \Rfunction{glm}.

\subsection{The \Rfunction{wedderburn} family}

In \citet{Wedd74} it was suggested to represent the mean of
a continuous response variable in
$[0,1]$ using a quasi-likelihood model with logit link and the
variance function $\mu^2(1-\mu)^2$.  This is not one of the variance
functions made available as standard in R's \Rfunction{quasi} family.  The
\Rfunction{wedderburn} family provides it.  As an example, Wedderburn's
analysis of data on leaf blotch on barley can be reproduced as follows:
<<wedderburn>>=
data(barley)  ##  data from Wedderburn (1974), see ?barley
logitModel <- glm(y ~ site + variety, family = wedderburn, data = barley)
fit <- fitted(logitModel)
print(sum((barley$y - fit)^2 / (fit * (1-fit))^2))
@
This agrees with the chi-squared value reported on page 331 of \citet{McCu89},
which differs slightly from Wedderburn's reported value.

\subsection{\Rfunction{termPredictors}}

The generic function \Rfunction{termPredictors} extracts a term-by-term
decomposition of the predictor function in a linear, generalized linear or
generalized nonlinear model.

As an illustrative example, we can decompose the linear predictor in the above
quasi-symmetry model as follows:
<<termPredictors>>=
print(temp <- termPredictors(quasi.symm))
rowSums(temp) - quasi.symm$linear.predictors
@

Such a decomposition might be useful, for example, in assessing the relative
contributions of different terms or groups of terms.

\section{Nonlinear Terms}
\label{nonlinear}

The \Rpackage{gnm} package provides a flexible framework for the specification
and
estimation of generalized models with nonlinear terms. Multiplicative
interaction terms can be estimated using the in-built capability of the
\Rfunction{gnm} function and are specified in the model formula using the symbolic
function \Rfunction{Mult}. Other nonlinear terms can be estimated using plug-in
functions for \Rfunction{gnm} and are specified using \Rfunction{Nonlin}.

There are two plug-in functions currently made available in
the \Rpackage{gnm} package: \Rfunction{MultHomog} for fitting multiplicative
interaction terms with homogeneous effects and \Rfunction{Dref} for fitting
diagonal reference terms. Users of \Rpackage{gnm} can define their own
custom plug-in functions to specify other types of nonlinear term.

\subsection{Multiplicative Interaction Terms using \Rfunction{Mult}}

Multiplicative interaction terms can be included in the formula argument to
\Rfunction{gnm} by using the symbolic wrapper function \Rfunction{Mult}.
Constituent multipliers\footnote{
A note on terminology: the rather cumbersome phrase `constituent multiplier', or
sometimes the abbreviation `multiplier', will
be used throughout this document in preference to the more elegant and standard
mathematical term `factor'.  This will avoid possible confusion with the
completely different meaning of the word `factor' --- that is, a categorical
variable --- in R.
}
in
the interaction are passed as unspecified arguments to \Rfunction{Mult} and are
expressed
by symbolic linear formulae. An intercept is automatically added to each
constituent multiplier unless otherwise specified. For example,
to fit the row-column association model
\[
\log \mu_{rc} = \alpha_r + \beta_c + \gamma_r\delta_c,
\]
also known as the Goodman RC model \citep{Good79}, the \Rfunarg{formula}
argument
of \Rfunction{gnm} would be
\begin{alltt}
    mu \twiddle\ R + C + Mult(-1 + R, -1 + C)
\end{alltt}
where \Robject{R} and \Robject{C} are row and column factors respectively.



\Rfunction{Mult} has one specified argument \Rfunarg{multiplicity}, which is
\Robject{1} by default. This argument determines the number of times that
the specified multiplicative structure appears in the model. For example,
\begin{alltt}
    mu \twiddle\ R + C + Mult(-1 + R, -1 + C, multiplicity = 2)
\end{alltt}
would give the RC(2) model \citep{Good79}
\[
\log \mu_{rc} = \alpha_r + \beta_c + \gamma_r\delta_c + \theta_r\phi_c.
\]

In some contexts, it may be desirable to constrain one or more of the
constituent multipliers so that it is always nonnegative.
This may be
achieved by specifying the multiplier as an exponential, as in the
following `uniform difference' model \citep{Xie92, Erik92}
\[
\log \mu_{rct} = \alpha_{rt} + \beta_{ct} + e^{\gamma_t}\delta_{rc}.
\]
Exponentiated constituent multipliers
are specified in \Rclass{gnm} models using the symbolic
function \Rfunction{Exp}; for example, the uniform difference model above
would be specified by the formula
\begin{alltt}
    mu \twiddle\ R:T + C:T + Mult(Exp(-1 + T), R:C)
\end{alltt}

\subsection{Other Nonlinear Terms using \Rfunction{Nonlin}}

Nonlinear terms which can not be specified using \Rfunction{Mult} may be
specified using \Rfunction{Nonlin}. This symbolic function indicates a term
which requires a plug-in function to estimate the associated
parameters. \Rfunction{Nonlin} takes a single argument, which is a call to the
relevant plug-in function.

For example, in the formula
\begin{alltt}
    mu ~ x + A + B + Nonlin(PlugInFunction(A, B, arg1 = x, arg2 = C))
\end{alltt}
the call to \Rfunction{Nonlin} is used to specify a term that requires the
plug-in function \Robject{PlugInFunction}.

The two plug-in functions already included in the
\Rpackage{gnm} package are described
below, followed by a guide to writing custom plug-in functions.

\subsubsection{\Rfunction{MultHomog}}

The \Rfunction{MultHomog} function provides the tools required to fit
multiplicative interaction terms with one component in which the constituent
multipliers are the effects of two or more factors and the effects of these
factors are constrained to be equal when the factor levels are equal. The
arguments of \Rfunction{MultHomog} are the factors in the interaction, which are
assumed to be objects of class \Rclass{factor}.

As an example, consider the following association model with homogeneous
row-column effects:
\[\log \mu_{rc} = \alpha_r + \beta_c + \theta_{r}I(r=c) + \gamma_r\gamma_c.\]
To fit this model, with response variable named \Robject{mu},
the formula argument to \Rfunction{gnm} would be
\begin{alltt}
    mu \twiddle\ R + C + Diag(R, C) + Nonlin(MultHomog(R, C))
\end{alltt}

If the factors passed to \Rfunction{MultHomog} do not have
exactly the same levels,
a common set of levels is obtained by taking the union of the levels of each
factor, sorted into increasing order.

\subsubsection{\Rfunction{Dref}}
\label{NonlinDref}

\Rfunction{Dref} is a plug-in function to fit diagonal reference terms involving
two or more factors with a common set of levels. A diagonal reference term
comprises an additive component for each factor. The component for factor $f$,
is given by
\[
w_f\gamma_l
\]
for an observation with level $l$ of factor $f$, where $w_f$ is the weight for
factor $f$ and $\gamma_l$ is the ``diagonal effect'' for level $l$.

The weights are constrained to be nonnegative and to sum to one so that a
``diagonal effect'', say $\gamma_l$, is the value of the diagonal reference term
for data points with level $l$ across the factors. \Rfunction{Dref} constrains
the weights by defining them as
\[
w_f = \frac{e^{\delta_f}}{\sum_i e^{\delta_i}}
\]
and estimating the $\delta_f$.

Factors in the interaction are passed to unspecified arguments of
\Rfunction{Dref}. For example, the following diagonal reference model for
a contingency table classified by the row factor \Robject{R}
and the column factor \Robject{C},
\[
\mu_{rc} =\frac{e^{\delta_1}}{e^{\delta_1} + e^{\delta_2}}\gamma_r +
\frac{e^{\delta_2}}{e^{\delta_1} + e^{\delta_2}}\gamma_c,
\]
would be specified by the formula
\begin{alltt}
    mu \twiddle\ -1 + Nonlin(Dref(R, C))
\end{alltt}

\Rfunction{Dref} has one specified argument \Rfunarg{formula}, which is a symbolic
description of the dependence of $\delta_f$ on any covariates.
For example, the formula
\begin{alltt}
    mu \twiddle\ -1 + x + Nonlin(Dref(R, C, formula = ~ 1 + x))
\end{alltt}
specifies the following diagonal reference model
\[
\mu_{rc} = \beta_Xx + \frac{e^{\xi_1 + \beta_1x}}{e^{\xi_1 + \beta_1x} + e^{\xi_2 + \beta_2x}}\gamma_r +
\frac{e^{\xi_2 + \beta_2x}}{e^{\xi_1 + \beta_x} + e^{\xi_2 + \beta_2x}}\gamma_c.
\]
The default value of \Rfunarg{formula} is \Robject{\twiddle 1}, so that
constant weights are estimated. The coefficients returned by \Rfunction{gnm} are
those that are directly estimated, i.e. the $\delta_f$ or the $\xi_f$ and
$\beta_f$, rather than the implied weights $w_f$.

\subsubsection{Custom Plug-in Functions}

Custom plug-in functions may be written to enable \Rfunction{gnm} to fit
nonlinear terms that can not be specified by \Rfunction{Mult}
or the plug-in functions provided by the \Rpackage{gnm} package.

There are no constraints on the arguments that a plug-in function may
take.  However it is important that \Rfunction{Nonlin}, when given a call to the
plug-in function, can determine the variables that are in the term, so that these
variables can be added to the model frame. By default, expressions passed to
unspecified arguments of the plug-in function are assumed to represent the
variables in the term.

If the default action of \Rfunction{Nonlin} will not capture the required
variables, a companion function must exist (in the environment of the
plug-in function), which takes the same arguments as the plug-in function and
returns deparsed expressions representing the necessary variables. The name of
this function must be the name of the plug-in function suffixed with
"Variables". For example, the (non-visible) companion function for
\Rfunction{Dref} is defined as
\begin{verbatim}
    DrefVariables <- function(..., formula = ~ 1) {
        as.character(c(match.call(expand.dots = FALSE)[[2]], formula[[2]]))
    }
\end{verbatim}
returning the expressions passed to unspecified arguments and the right-hand
side of the formula passed to \Rfunarg{formula}, as character strings. For
instance
@
<<DrefVariables_example>>=
gnm:::DrefVariables(A, B, formula = ~ 1 + C)
@ %def
from which \Rfunction{Nonlin} will know that \Robject{A}, \Robject{B} and
\Robject{C} need to be added to the model frame.

The call to the plug-in function is evaluated in the environment of
the model frame and in the enclosing environment of the parent frame
of the call to \Rfunction{gnm}. This should ensure that variables passed
directly to the plug-in function can be found. However, to evaluate variables
within the plug-in function, it may be necessary to access the model frame,
which can be obtained using the function \Rfunction{getModelFrame}.

For example, the factors in a \Rfunction{Dref} term are passed directly to
unspecified arguments, so the dummy variables for these factors can be found as
follows
\begin{alltt}
    # get design matrices for Dref factors
    designList <- lapply(list(...), class.ind)
\end{alltt}
But any covariates on which the weights depend are only represented symbolically
in the \Rfunarg{formula} argument, so the design matrix for these variables must
be found in the context of the model frame
\begin{alltt}
    ## get design matrix for local structure
    gnmData <- getModelFrame()
    local <- model.matrix(formula, data = gnmData)
\end{alltt}

The plug-in function should return a list with at least the following
three components:
\begin{description}
\item[\Robject{labels}]
  a character vector of labels for the
  parameters (to which \Rfunction{gnm} will prefix the call to the
  plug-in function).
\item[\Robject{predictor}]
  a function which takes a vector of parameter estimates
  and returns either a vector of fitted values or a matrix whose columns are
  additive components of the fitted values.
\item[\Robject{localDesignFunction}]
  a function which takes the specified
  arguments \Rfunarg{coef} (a vector of parameter estimates) and
  \Rfunarg{predictor} (the result of the predictor function), and returns the
  local design matrix. If the plug-in function does not return a \Robject{start}
  component (see below), the \Robject{localDesignFunction} must also take the
  argument \Rfunarg{ind}, which specifies the index of a column to be returned
  instead of the full matrix.
\end{description}
and optionally one further component
\begin{description}
\item[\Robject{start}]
  a vector of default starting values for the
  parameters. \Robject{NA} may be used to indicate parameters which
  may be treated as linear for the purpose of finding starting
  values, given the non-\Robject{NA} values. See Section \ref{start} for details of
  how these starting values will be used if provided and the starting procedure
  for nonlinear parameters that will be used otherwise.
\end{description}

As an example of a \Robject{start} component, \Rfunction{Dref} returns
\begin{alltt}
    c(runif(nLocal) - 0.5, rep(0.5, nGlobal))
\end{alltt}
where \Robject{nLocal} is the number of weight parameters (parameters which are
``local'' to a specific factor) and \Robject{nGlobal} is the number of diagonal
effects (``global'' level effects across factors). The randomness in the
starting values for the weight parameters ensures that arbitrariness of the
final parameterization is emphasised.

The \Rfunction{MultHomog} function provides a simple example of a
\Robject{predictor} component:
\begin{alltt}
    predictor <- function(coef) \{
        do.call("pprod", lapply(designList, "%*%", coef))
    \}
\end{alltt}
which computes the product of the vectors found by multiplying the design matrix
for each factor in the interaction (held in \Robject{designList}) by the
homogeneous coefficients (in \Robject{coef}). This function takes advantage of
\emph{lexical scoping}: \Robject{designList} is an object defined in
\Rfunction{MultHomog}, which \Rfunction{predictor} is able to find because
\Rfunction{predictor} is also defined in \Rfunction{MultHomog} and hence
\Rfunction{MultHomog} is the enclosing environment of \Rfunction{predictor}.

The \Rfunction{localDesignFunction} created by \Rfunction{MultHomog}
is slightly more complicated:
\begin{alltt}
    localDesignFunction <- function(coef, ind = NULL, ...) \{
        X <- 0
        vList <- lapply(designList, "%*%", coef)
        for (i in seq(designList)) \{
            if (is.null(ind))
                X <- X + designList[[*]] * drop(do.call("pprod", vList[-i]))
            else
                X <- X + designList[[]][, ind] *
                    drop(do.call("pprod", vList[-i]))
        \}
        X
    \}
\end{alltt}
Since the result of the predictor function is not needed here, the local design
function does not have the specified argument \Rfunarg{predictor}, but allows such an
argument to be passed to the function by the use of the special argument
`\Robject{...}'. Since \Rfunction{MultHomog} does not return a \Robject{start}
component, the local design function can optionally return a single column of
the local design matrix as specified by \Rfunarg{ind}. This functionality is
required by the default starting procedure for nonlinear parameters.

\section{Controlling the Fitting Procedure}

The \Rfunction{gnm} function has a number of arguments which affect the way a
model will be fitted.  Basic control parameters can be set using the arguments
\Rfunarg{tolerance}, \Rfunarg{iterStart} and \Rfunarg{iterMax}. Starting values
for the parameter estimates can be set by \Rfunarg{start} and parameters can be
constrained to zero by specifying a \Rfunarg{constrain} argument. Finally
parameters of a stratification factor can be handled more efficiently by
specifying the factor in an \Rfunarg{eliminate} argument. These options are
described in more detail below.

\subsection{Basic control parameters}

The arguments \Rfunarg{iterStart} and \Rfunarg{iterMax} control respectively the
number of starting iterations (where applicable) and the number of main
iterations used by the fitting algorithm. The progress of these iterations can
be followed by setting either \Rfunarg{verbose} or \Rfunarg{trace} to \Robject{TRUE}.
If \Rfunarg{verbose} is \Robject{TRUE} and \Rfunarg{trace} is \Robject{FALSE},
which is the default setting, progress is indicated by printing the character
``.'' at the beginning of each iteration.  If \Rfunarg{trace} is \Robject{TRUE},
the deviance is printed at the beginning of each iteration (over-riding the
printing of ``.'' if necessary). Whenever \Rfunarg{verbose} is \Robject{TRUE},
additional messages indicate each stage of the fitting process and diagnose any
errors that cause that cause the algorithm to restart.

The fitting algorithm will terminate before the number of main iterations has
reached \Rfunarg{iterMax} if the convergence criteria have been met, with
tolerance specified by \Rfunarg{tolerance}. Convergence is judged by comparing
the squared components of the score vector with corresponding elements of the
diagonal of the Fisher information matrix. If, for all components of the score
vector, the ratio is less than \Robject{tolerance$^2$}, or the corresponding diagonal
element of the Fisher information matrix is less than 1e-20, the algorithm is
deemed to have converged.

\subsection{Using \Rfunarg{start}}
\label{start}

In some contexts, the default starting values may not be appropriate and the
algorithm will fail to converge, or perhaps only converge after a large number
of iterations. Alternative starting values may be passed on to \Rfunction{gnm}
by specifying a \Rfunarg{start} argument. This should be a numeric vector of
length equal to the number of parameters (or possibly the non-eliminated
parameters, see Section \ref{eliminate}), however missing starting values
(\Robject{NA}s) are allowed.

If there is no user-specified starting value for a parameter, the
default value is used. This feature is particularly useful when adding terms to
a model, since the estimates from the original model can be used as starting
values, as in this example:
\begin{alltt}
    model1 <- gnm(mu \twiddle\ R + C + Mult(-1 + R, -1 + C))
    model2 <- gnm(mu \twiddle\ R + C + Mult(-1 + R, -1 + C, multiplicity = 2),
                  start = c(coef(model1), rep(NA, 10))
\end{alltt}
The \Rfunction{gnm} call can be made with \texttt{method = "coefNames"} to
identify the parameters of a model prior to estimation, to assist with the
specification of arguments such as \Rfunarg{start}.

The starting procedure used by \Rfunction{gnm} is as follows
\begin{enumerate}
\item
Generate starting values $\theta_i$ for all parameters $i = 1, \ldots, p$ from
the Uniform($-0.1$, $0.1$) distribution. Shift these values away from zero as
follows
\begin{equation*}
\theta_i = \begin{cases}
    \theta_i - 0.1 &  \text{if } \theta_i < 1 \\
    \theta_i + 0.1 & \text{otherwise}
\end{cases}
\end{equation*}
\item
Replace generic starting values with default starting values set by plug-in
functions, where applicable.
\item
Replace default starting values with any starting values specified by the
\Rfunarg{start} argument of \Rfunction{gnm}.
\item
Compute the \Rfunction{glm} estimate of any parameters that may be treated as
linear (i.e. those in linear terms or those with a default starting value of
\Robject{NA} set by a plug-in function), offsetting the contribution to
the predictor of any terms specified by \Rfunarg{start} or a plug-in function.
\item
Run starting iterations: update one at a time any remaining nonlinear parameters
not specified by \Rfunarg{start} or a plug-in function, updating \emph{all}
parameters that may be treated as linear after each round of updates.
\end{enumerate}
Note that no starting iterations (step 5) will be run if all parameters are
linear, or if all nonlinear parameters are specified by \Rfunarg{start} or a
plug-in function.

\subsection{Using \Rfunarg{constrain}}
\label{constrain}

By default, \Rfunction{gnm} only imposes identifiability constraints according
to the general conventions used by \Robject{R} to handle linear aliasing. Therefore
models that have any nonlinear terms will be usually be over-parameterized and
\Rfunction{gnm} will return a random parameterization for unidentified
coefficients.

To illustrate this point, consider the following application of \Rfunction{gnm},
discussed later in Section \ref{RCmodels}:
<<RC_homogeneous_model_1>>=
data(occupationalStatus)
set.seed(1)
RChomog1 <- gnm(Freq ~ origin + destination + Diag(origin, destination) +
               Nonlin(MultHomog(origin, destination)), family = poisson,
               data = occupationalStatus, verbose = FALSE)
@
Running the analysis again from a different seed
<<RC_homogeneous_model_2>>=
set.seed(2)
RChomog2 <- eval(RChomog1$call)
@
gives a different representation of the same model:
<<Compare_coefficients>>=
compareCoef <- cbind(coef(RChomog1), coef(RChomog2))
colnames(compareCoef) <- c("RChomog1", "RChomog2")
round(compareCoef, 4)
@
Even though the linear terms are constrained, the parameter estimates for the
main effects of \Robject{origin} and \Robject{destination} still change, because
these terms are aliased with the higher order multiplicative interaction, which
is unconstrained.

Standard errors are only meaningful for identified parameters and hence the
output of \Rfunction{summary.gnm} will show clearly which coefficients are
estimable:
<<Summarize_model>>=
summary(RChomog2)
@

Additional constraints may be specified through the \Rfunarg{constrain} argument
of \Rfunction{gnm}. This argument indicates parameters that are to be
constrained to zero in the fitting process. Parameters can be indicated by a
logical vector, a numeric vector of indices, a character vector of names or,
if \texttt{constrain = "pick"} they can be selected through a \emph{Tk} dialog.

In the case above, constraining one level of the homogeneous multiplicative
factor is sufficient to make the parameters of the nonlinear term
identifiable, and hence all parameters in the model identifiable. For example,
setting the last level of the homogeneous multiplicative factor to zero,
<<RC_homogeneous_constrained_model>>=
multCoef <- coef(RChomog1)[grep("Mult", names(coef(RChomog1)))]
set.seed(1)
RChomogConstrained1 <- update(RChomog1, constrain = 31,
                              start = c(rep(NA, 23), multCoef - multCoef[8]))
set.seed(2)
RChomogConstrained2 <- eval(RChomogConstrained1$call)
identical(coef(RChomogConstrained1), coef(RChomogConstrained2))
@
gives the same results regardless of the random seed set beforehand.

It is not usually so straightforward to constrain all the parameters in a
generalized nonlinear model. However, the simple constraints imposed by
\Rfunarg{constrain} are often sufficient to make particular coefficients of
interest identifiable. The functions \Rfunction{checkEstimable} or
\Rfunction{getContrasts}, described in Section \ref{Methods},
may be used to check whether particular contrasts are estimable.

\subsection{Using \Rfunarg{eliminate}}
\label{eliminate}

Sometimes a model will include a ``stratification'' factor which identifies
units for which a unit-specific intercept should be estimated. It is often the
case that such factors have a large number of levels and though they are
required in the model, are not of direct interest in themselves.

The \Rfunarg{eliminate} argument of \Rfunction{gnm} can be used to specify a
stratification factor in a model, so that this factor can be handled more
efficiently. The factor should be specified by an expression, which is
interpreted as the first term in the model formula, replacing any intercept
term. So in terms of the structure of the model,
\begin{alltt}
    gnm(mu ~ A + B + Mult(A, B), eliminate = strata1:strata2)
\end{alltt}
is equivalent to
\begin{alltt}
    gnm(mu ~ -1 + strata1:strata2 + A + B + Mult(A, B))
\end{alltt}
However specifying a stratification factor through \Rfunarg{eliminate} has two
advantages over the standard specification. First, the structure of the
eliminated factor is exploited so that computational speed is improved ---
substantially so if the number of eliminated parameters is large. Second, the
eliminated parameters are excluded from summaries of the model so that they
focus on the coefficients of interest.

The \Rfunarg{eliminate} feature is useful, for example, when
multinomial-response models are fitted by using the well known equivalence
between multinomial and (conditional) Poisson likelihoods.  In such situations
the sufficient statistic involves a potentially large number of fixed
multinomial row totals, and the corresponding parameters are of no
substantive interest.  For an example see Section \ref{Stereotype} below.

The \Rfunarg{eliminate} feature as implemented in \Rpackage{gnm} extends the
earlier work of \cite{Hatz04} to a broader class of models and to
over-parameterized model representations.

\section{Methods and Accessor functions}
\label{Methods}

\subsection{Methods}
\label{specificMethods}

The \Rfunction{gnm} function returns
an object of class \Robject{c("gnm", "glm", "lm")}. There
are several methods that have been written for objects of class \Rclass{glm}
or \Rclass{lm} to facilitate inspection of fitted models.
Out of the generic functions in the \Rpackage{base},
\Rpackage{stats} and \Rpackage{graphics} packages for which methods have been
written
for \Rclass{glm} or \Rclass{lm} objects, Figure \ref{glm.lm} shows those
that can be used to analyse \Rclass{gnm} objects, whilst Figure
\ref{!glm.lm} shows
those that are not implemented for \Rclass{gnm} objects.

\begin{figure}[!tbph]
    \centering
    \begin{fbox}
        {
          \begin{tabular*}{7.5cm}{@{\extracolsep{\fill}}lll@{\extracolsep{\fill}}}
              anova	&	hatvalues	&	rstandard	\\
              case.names	&	labels	&	summary	\\
              coef	&	logLik	&	variable.names	\\
              cooks.distance	&	model.frame	&	vcov	\\
              deviance	&	model.matrix	&	weights	\\
              extractAIC	&	plot	&		\\
              family	&	print	&		\\
              formula	&	residuals	&		\\
          \end{tabular*}
        }
    \end{fbox}
    \caption{Generic functions in the \Rpackage{base}, \Rpackage{stats} and
      \Rpackage{graphics} packages that can be used to analyse
      \Rclass{gnm} objects.}
    \label{glm.lm}
\end{figure}

\begin{figure}[!tbph]
    \centering
    \begin{fbox}
        {
          \begin{tabular*}{4.5cm}{@{\extracolsep{\fill}}ll@{\extracolsep{\fill}}}
              add1	&	dummy.coef	\\
              alias	&	effects	\\
              confint	&	influence	\\
              dfbeta	&	kappa	\\
              dfbetas	&	predict	\\
              drop1	&	proj	\\

          \end{tabular*}
        }
    \end{fbox}
    \caption{Generic functions in the \Rpackage{base}, \Rpackage{stats} and
      \Rpackage{graphics} packages for which methods have been written for
      \Rclass{glm} or \Rclass{lm} objects, but which are \emph{not}
      implemented for \Rclass{gnm} objects.}
    \label{!glm.lm}
\end{figure}

In addition to the accessor functions shown in Figure \ref{glm.lm}, the
\Rpackage{gnm} package provides a new generic function called
\Rfunction{termPredictors}
that has methods for objects of class \Rclass{gnm}, \Rclass{glm} and
\Rclass{lm}. This function returns the additive contribution of each term to
the predictor.  See Section \ref{glms} for an example of its use.

Most of the methods listed in Figure \ref{glm.lm} can be used as they would be
for \Rclass{glm} or \Rclass{lm} objects, however care must be taken with
\Rmethod{vcov}, as the variance-covariance matrix will depend on the
parameterization of the model. In particular, standard errors calculated using
the variance-covariance matrix will only be valid for parameters or contrasts
that are estimable!

\subsection{\Rfunction{checkEstimable}}
\label{checkEstimable}

The \Rfunction{checkEstimable} function can be used to check the
estimability of
contrasts. Consider the following model, that is described later in Section
\ref{Unidiff}:
<<Double_UNIDIFF_model>>=
data(cautres)
doubleUnidiff <- gnm(Freq ~ election:vote + election:class:religion
                     + Mult(Exp(election - 1), religion:vote - 1) +
                     Mult(Exp(election - 1), class:vote - 1), family = poisson,
                     data = cautres)
@
The effects of the first constituent multiplier in the first multiplicative
interaction are identified when the estimate of one of these effects is
constrained to zero, say for the effect of the first level. The parameters to be
estimated are then the differences between each effect and the effect of the
first level. These differences can be represented by a contrast matrix as
follows:
<<Contrast_matrix>>=
coefs <- names(coef(doubleUnidiff))
contrCoefs <- coefs[grep("Mult1.Factor1", coefs)]
nContr <- length(contrCoefs)
contrMatrix <- matrix(0, length(coefs), nContr,
                      dimnames = list(coefs, contrCoefs))
contr <- contr.sum(contrCoefs)
# switch round to contrast with first level
contr <- rbind(contr[nContr, ], contr[-nContr, ])
contrMatrix[contrCoefs, 2:nContr] <- contr
contrMatrix[contrCoefs, 2:nContr]
@
Then their estimability can be checked using \Rfunction{checkEstimable}
<<Check_estimability_1>>=
checkEstimable(doubleUnidiff, contrMatrix)
@
which confirms that the effects for the other three levels are estimable when
the effect for the last level is set to zero.

However, applying the equivalent constraint to the second constituent
multiplier in the interaction is not sufficient to make the parameters in that
multiplier estimable:
<<Check_estimability_2>>=
coefs <- names(coef(doubleUnidiff))
contrCoefs <- coefs[grep("Mult1.Factor2", coefs)]
nContr <- length(contrCoefs)
contrMatrix <- matrix(0, length(coefs), length(contrCoefs),
                      dimnames = list(coefs, contrCoefs))
contr <- contr.sum(contrCoefs)
contrMatrix[contrCoefs, 2:nContr] <- rbind(contr[nContr, ], contr[-nContr, ])
checkEstimable(doubleUnidiff, contrMatrix)
@

\subsection{\Rfunction{getContrasts}, \Rfunction{se}}
\label{getContrasts}

To investigate simple ``sum to zero'' contrasts such as those above, it
is easiest to use the \Rfunction{getContrasts} function, which checks the
estimability of the contrasts and returns the parameter estimates with their
standard errors. Returning to the example of the first constituent multiplier
in the first multiplicative interaction term, the differences between each
election and the first can be obtained as follows:
<<Get_contrasts_1>>=
coefs.of.interest <- grep("Mult1.Factor1", names(coef(doubleUnidiff)))
getContrasts(doubleUnidiff, coefs.of.interest)
@ %def
Attempting to obtain the equivalent contrasts for the second
(religion-vote association) multiplier produces the
following result:
<<Get_contrasts_2>>=
coefs.of.interest <- grep("Mult1.Factor2", names(coef(doubleUnidiff)))
getContrasts(doubleUnidiff, coefs.of.interest)
@ %def

For approximate inference on more general linear combinations of parameters,
the lower-level \Rfunction{se} function (which is called internally by
\Rfunction{getContrasts} and by the \Rmethod{summary} method)
can be used directly.  See \texttt{help(se)} for details.

\subsection{\Rfunction{residSVD}}
\label{residSVD}
Sometimes it is useful to operate on the residuals of a model in order
to create informative summaries of residual variation, or to obtain good
starting values for additional parameters in a more elaborate model.  The
relevant arithmetical operations are weighted means of the so-called
\emph{working residuals}.

The \Rfunction{residSVD} function facilitates one particular residual
analysis that is often useful when considering multiplicative interaction
between factors as a model elaboration: in effect, \Rfunction{residSVD}
provides a crude, direct estimate of the parameters of such an interaction, by
performing an appropriately weighted singular value decomposition on the
working residuals.

As an illustration, consider the biplot model described in
Section~\ref{biplot} below.  We can proceed by fitting a smaller model,
then use \Rfunction{residSVD} to obtain starting values for the parameters
in the bilinear term:
<<residSVD>>=
emptyModel <- gnm(y ~ -1, family = wedderburn, data = barley)
biplotStart <- residSVD(emptyModel, barley$site, barley$variety, 2)
biplotModel <- gnm(y ~ -1 + Mult(-1 + site, -1 + variety, multiplicity = 2), family = wedderburn, data = barley, start =  biplotStart)
@ %def
In this instance, where the number of parameters was fairly small, the
use of purposive (as opposed to random) starting values had little effect
(for example, the number of iterations needed to fit the model is largely
unaffected).  In other situations, where the number of parameters is much
larger, the use of \Rfunction{residSVD} may be crucial to success in
fitting the model: an example can be seen in \texttt{help(House2001)}, where
the number of multiplicative parameters is in the hundreds.

The \Rfunction{residSVD} result provides a crude approximation to the MLE
of the enlarged model, as can be seen in this plot:
<<residSVDplot fig=TRUE>>=
plot(coef(biplotModel), as.vector(biplotStart), main = "Comparison of
residSVD and MLE for a 2-dimensional biplot model")
@ %def

\section{Examples}
\label{Examples}

This section provides some examples of the wide range of models that may be fitted
using the \Rpackage{gnm} package. Sections \ref{RCmodels}, \ref{Dref} and
\ref{Unidiff} consider various models for contingency tables; Section
\ref{GAMMI} considers AMMI and GAMMI models which are typically used in
agricultural applications, and Section \ref{Stereotype} considers the stereotype
model, which is used to model an ordinal response.

\subsection{Row-column Association Models}
\label{RCmodels}

There are several models that have been proposed for modelling the relationship
between the cell means of a contingency table and the cross-classifying
factors. The following examples consider the row-column association models
proposed by \citet{Good79}. The examples shown use data from two-way contingency
tables, but the \Rpackage{gnm} package can also be used to fit the equivalent
models for higher order tables.

\subsubsection{RC(1) model}

The RC(1) model is a row and column association model with the interaction
between row and column factors represented by one component of the
multiplicative
interaction. If the rows are indexed by $r$ and the columns by $c$, then the
log-multiplicative form of the RC(1) model for the cell means $\mu_{rc}$ is
given by
\[\log \mu_{rc} = \alpha_r + \beta_c + \gamma_r\delta_c. \]

We shall fit this model to the \Robject{mentalHealth} data set taken from
\citet{Agre02} page 381, which is a two-way contingency table classified
by the child's
mental impairment (MHS) and the parents' socioeconomic status (SES). Although
both of these factors are ordered, we do not wish to use polynomial contrasts
in the model, so we begin by setting the contrasts attribute of these
factors to \Robject{``treatment''}:
<<Set_contrasts_attribute>>=
set.seed(1)
data(mentalHealth)
mentalHealth$MHS <- C(mentalHealth$MHS, treatment)
mentalHealth$SES <- C(mentalHealth$SES, treatment)
@
The \Rclass{gnm} model is then specified as follows, using the poisson family
with a log link function:
<<RC1_model>>=
RC1model <- gnm(count ~ SES + MHS + Mult(-1 + SES, -1 + MHS),
                family = poisson, data = mentalHealth)
RC1model
@ %def
The row scores (parameters 10 to 15) and the column scores (parameters 16 to 19)
of the multiplicative interaction can be normalized as in Agresti's eqn (9.15):
<<Normalize_scores>>=
rowProbs <- with(mentalHealth, tapply(count, SES, sum) / sum(count))
colProbs <- with(mentalHealth, tapply(count, MHS, sum) / sum(count))
rowScores <- coef(RC1model)[10:15]
colScores <- coef(RC1model)[16:19]
rowScores <- rowScores - sum(rowScores * rowProbs)
colScores <- colScores - sum(colScores * colProbs)
beta1 <- sqrt(sum(rowScores^2 * rowProbs))
beta2 <- sqrt(sum(colScores^2 * colProbs))
assoc <- list(beta = beta1 * beta2,
              mu = rowScores / beta1,
              nu = colScores / beta2)
assoc
@ %def

\subsubsection{RC(2) model}

The RC(1) model can be extended to an RC($m$) model with $m$ components of the
multiplicative interaction. For example, the RC(2) model is given by
\[
\log \mu_{rc} = \alpha_r + \beta_c + \gamma_r\delta_c + \theta_r\phi_c.
\]
Extra instances of the multiplicative interaction can be specified by the
\Rfunarg{multiplicity} argument of \Rfunction{Mult}, so the RC(2) model can be
fitted to the \Robject{mentalHealth} data as follows
<<RC2_model>>=
RC2model <- gnm(count ~ SES + MHS +
                Mult(-1 + SES, -1 + MHS, multiplicity = 2),
                family = poisson, data = mentalHealth)
RC2model
@

\subsubsection{Homogeneous effects}

If the row and column factors have the same levels, or perhaps some levels in
common, then the row-column interaction could be modelled by a multiplicative
interaction with homogeneous effects, that is
\[\log \mu_{rc} = \alpha_r + \beta_c + \gamma_r\gamma_c.\]
For example, the \Robject{occupationalStatus} data set from \citet{Good79} is a
contingency table classified by the occupational status of fathers (origin) and
their sons (destination). \citet{Good79} fits a row-column association model
with homogeneous effects to these data after deleting the cells on the main
diagonal. Equivalently we can account for the diagonal effects by a separate
\Rfunction{Diag} term:
@
<<Homogeneous_effects>>=
data(occupationalStatus)
RChomog <- gnm(Freq ~ origin + destination + Diag(origin, destination) +
               Nonlin(MultHomog(origin, destination)), family = poisson,
               data = occupationalStatus)
RChomog
@ %def

To determine whether it would be better to allow for heterogeneous effects on
the association of the fathers' occupational status and the sons' occupational
status, we can compare this model to the RC(1) model for these data:
<<Heterogeneous_effects>>=
data(occupationalStatus)
RCheterog <- gnm(Freq ~ origin + destination + Diag(origin, destination) +
               Mult(origin, destination), family = poisson,
               data = occupationalStatus)
RChomog$dev - RCheterog$dev
RChomog$df.residual - RCheterog$df.residual
@
In this case there is little gain in allowing heterogeneous effects.

\subsection{Diagonal Reference Models}
\label{Dref}

Diagonal reference models, proposed by \citet{Sobe81, Sobe85}, are designed for
contingency tables classified by factors with the same levels. The cell
means are modelled as a function of the diagonal effects, i.e., the mean
responses of the `diagonal' cells in which the levels of the row and
column factors are the same.

\subsubsection*{\Rfunction{Dref} example 1: Political consequences of
social mobility}

To illustrate the use of diagonal reference models we shall use the
\Robject{voting} data from \citet{Clif93}. The data come from the 1987 British
general election and are the percentage voting Labour in groups cross-classified
by the class of the head of household (\Robject{destination}) and the class of
their father (\Robject{origin}). In order to weight these percentages by the
group size, we first back-transform them to the counts of those voting Labour
and those not voting Labour:
@
<<Transform_to_counts>>=
set.seed(1)
data(voting)
count <- with(voting, percentage/100 * total)
yvar <- cbind(count, voting$total - count)
@ %def

The grouped percentages may be modelled by a basic diagonal reference model, that
is, a weighted sum of the diagonal effects for the corresponding origin and
destination classes. This model may be expressed as
\[
\mu_{od} = \frac{e^{\delta_1}}{e^{\delta_1} + e^{\delta_2}}\gamma_o +
\frac{e^{\delta_2}}{e^{\delta_1} + e^{\delta_2}}\gamma_d .
\]
See Section \ref{NonlinDref} for more detail on the parameterization.

The basic diagonal reference model may be fitted using \Rfunction{gnm} as
follows
@
<<Class_mobility>>=
classMobility <- gnm(yvar ~ Nonlin(Dref(origin, destination)),
                       family = binomial, data = voting)
classMobility
@ %def
and the origin and destination weights can be evaluated as below
@
<<Class_mobility_weights>>=
prop.table(exp(coef(classMobility)[2:3]))
@ %def
This model is slightly different from that reported by \citet{Clif93}.  The reason
for this is unclear: we are confident that the above results are correct for the
data as given in \citet{Clif93}, but have not been able to confirm that the data
as printed in the journal were exactly as used in Clifford and Heath's
analysis.

\citet{Clif93} suggest that movements in and out of the salariat (class 1)
should be treated differently from movements between the lower classes (classes
2 - 5), since the former has a greater effect on social status. Thus they
propose the following model
\begin{equation*}
\mu_{od} = \begin{cases}
\dfrac{e^{\delta_1}}{e^{\delta_1} + e^{\delta_2}}\gamma_o +
\dfrac{e^{\delta_2}}{e^{\delta_1} + e^{\delta_2}}\gamma_d & \text{if } o = 1\\
\\
\dfrac{e^{\delta_3}}{e^{\delta_3} + e^{\delta_4}}\gamma_o +
\dfrac{e^{\delta_4}}{e^{\delta_3} + e^{\delta_4}}\gamma_d & \text{if } d = 1\\
\\
\dfrac{e^{\delta_5}}{e^{\delta_5} + e^{\delta_6}}\gamma_o +
\dfrac{e^{\delta_6}}{e^{\delta_5} + e^{\delta_6}}\gamma_d & \text{if } o \ne 1
\text{ and } d \ne 1
\end{cases}
\end{equation*}
To fit this model we define factors indicating movement in (upward) and out
(downward) of the salariat
@
<<Salariat_factors>>=
upward <- with(voting, origin != 1 & destination == 1)
downward <- with(voting, origin == 1 & destination != 1)
@ %def
Then the diagonal reference model with separate weights for socially mobile
groups can be estimated as follows
@
<<Social_mobility>>=
socialMobility <- gnm(yvar ~ Nonlin(Dref(origin, destination,
                                         formula = ~ 1 + downward + upward)),
                      family = binomial, data = voting)
socialMobility
@ %def
The weights for those moving into the salariat, those moving out of the
salariat and those in any other group, can be evaluated as below
@
<<social_mobility_weights>>=
prop.table(exp(coef(socialMobility)[c(4, 7)] + coef(socialMobility)[c(2, 5)]))
prop.table(exp(coef(socialMobility)[c(3, 6)] + coef(socialMobility)[c(2, 5)]))
prop.table(exp(coef(socialMobility)[c(2, 5)]))
@ %def
Again, the results differ slightly from those reported by \citet{Clif93}, but
the essence of the results is the same: the origin weight is much larger for the
downwardly mobile groups than for the other groups. The weights for the upwardly
mobile groups are very similar to the base level weights, so the model may be
simplified by only fitting separate weights for the downwardly mobile groups:
@
<<Downward_mobility>>=
downwardMobility <- gnm(yvar ~ Nonlin(Dref(origin, destination,
                                           formula = ~ 1 + downward)),
                        family = binomial, data = voting)
downwardMobility
prop.table(exp(coef(downwardMobility)[c(3, 5)] +
               coef(downwardMobility)[c(2, 4)]))
prop.table(exp(coef(downwardMobility)[c(2, 4)]))
@ %def

\subsubsection*{\Rfunction{Dref} example 2: Conformity to parental rules}

%\SweaveInput{vanDerSlikEg.Rnw}

Another application of diagonal reference models is given by
\citet{Vand02}. The data from this paper are not publicly available\footnote{
We thank Frans van der Slik for his kindness in sending us the data.}, but we
shall show how the models presented in the paper may be estimated using
\Rfunction{gnm}.

The data relate to the value parents place on their children conforming to their
rules. There are two response variables: the mother's conformity score (MCFM)
and the father's conformity score (FCFF). The data are cross-classified by two
factors describing the education level of the mother (MOPLM) and the father
(FOPLF), and there are six further covariates (AGEM, MRMM, FRMF, MWORK, MFCM and
FFCF).

In their baseline model for the mother's conformity score, \citet{Vand02}
include five of the six covariates (leaving out the father's family conflict
score, FCFF) and a diagonal reference term with constant weights based on the
two education factors. This model may be expressed as
\[
\mu_{rc} = \beta_1x_1 + \beta_2x_2 + \beta_3x_3 +\beta_4x_4 +\beta_5x_5 +
\frac{e^{\delta_1}}{e^{\delta_1} + e^{\delta_2}}\gamma_r +
\frac{e^{\delta_2}}{e^{\delta_1} + e^{\delta_2}}\gamma_c .
\]

The baseline model can be fitted as follows:
\begin{alltt}
> set.seed(1)
>  A <- gnm(MCFM ~ -1 + AGEM + MRMM + FRMF + MWORK + MFCM +
+           Nonlin(Dref(MOPLM, FOPLF)), family = gaussian, data = conformity,
+           verbose = FALSE)
> A

Call:
gnm(formula = MCFM ~ -1 + AGEM + MRMM + FRMF + MWORK + MFCM +
    Nonlin(Dref(MOPLM, FOPLF)), family = gaussian, data = conformity,
    verbose = FALSE)


Coefficients:
                    AGEM                      MRMM                      FRMF
                 0.06364                  -0.32425                  -0.25324
                   MWORK                      MFCM  Dref(MOPLM, FOPLF).MOPLM
                -0.06430                  -0.06043                  -0.33730
Dref(MOPLM, FOPLF).FOPLF      Dref(MOPLM, FOPLF).1      Dref(MOPLM, FOPLF).2
                -0.02507                   4.95123                   4.86328
    Dref(MOPLM, FOPLF).3      Dref(MOPLM, FOPLF).4      Dref(MOPLM, FOPLF).5
                 4.86458                   4.72343                   4.43516
    Dref(MOPLM, FOPLF).6      Dref(MOPLM, FOPLF).7
                 4.18873                   4.43379

Deviance:            425.3389
Pearson chi-squared: 425.3389
Residual df:         576
\end{alltt}
The coefficients of the covariates are not aliased with the parameters of the
diagonal reference term and thus the basic identifiability constraints that have
been imposed are sufficient for these parameters to be identified. The diagonal
effects do not need to be constrained as they represent contrasts with the
off-diagonal cells.  Therefore the only unidentified parameters in this model
are the weight parameters. This is confirmed in the summary of the model:
\begin{alltt}
> summary(A)

Call:
gnm(formula = MCFM ~ -1 + AGEM + MRMM + FRMF + MWORK + MFCM +
    Nonlin(Dref(MOPLM, FOPLF)), family = gaussian, data = conformity,
    verbose = FALSE)


Deviance Residuals:
     Min        1Q    Median        3Q       Max
-3.63689  -0.50383   0.01714   0.56752   2.25140

Coefficients:
                         Estimate Std. Error t value Pr(>|t|)
AGEM                      0.06364    0.07375   0.863  0.38859
MRMM                     -0.32425    0.07766  -4.175 3.44e-05
FRMF                     -0.25324    0.07681  -3.297  0.00104
MWORK                    -0.06430    0.07431  -0.865  0.38727
MFCM                     -0.06043    0.07123  -0.848  0.39663
Dref(MOPLM, FOPLF).MOPLM -0.33730         NA      NA       NA
Dref(MOPLM, FOPLF).FOPLF -0.02507         NA      NA       NA
Dref(MOPLM, FOPLF).1      4.95123    0.16639  29.757  < 2e-16
Dref(MOPLM, FOPLF).2      4.86328    0.10436  46.601  < 2e-16
Dref(MOPLM, FOPLF).3      4.86458    0.12855  37.842  < 2e-16
Dref(MOPLM, FOPLF).4      4.72343    0.13523  34.928  < 2e-16
Dref(MOPLM, FOPLF).5      4.43516    0.19315  22.963  < 2e-16
Dref(MOPLM, FOPLF).6      4.18873    0.17142  24.435  < 2e-16
Dref(MOPLM, FOPLF).7      4.43379    0.16903  26.231  < 2e-16

(Dispersion parameter for gaussian family taken to be 0.7384355)

Std. Error is NA where coefficient has been constrained or is unidentified

Residual deviance: 425.34 on 576 degrees of freedom
AIC: 1507.8

Number of iterations: 10

\end{alltt}
The over-parameterization of the weights is immaterial, since the weights have
been constrained to sum to one as described earlier, so the weights themselves
are estimable. The weights may be evaluated as follows:
\begin{alltt}
> prop.table(exp(coef(A)[6:7]))
Dref(MOPLM, FOPLF).MOPLM Dref(MOPLM, FOPLF).FOPLF
               0.4225701                0.5774299
\end{alltt}
giving the values reported by \citet{Vand02}. All the other coefficients of
model A are the same as those reported by \citet{Vand02} except the coefficients
of the mother's gender role (MRMM) and the father's gender role
(FRMF). \citet{Vand02} reversed the signs of the coefficients of these factors
since they were coded in the direction of liberal values, unlike the other
covariates. However, simply reversing the signs of these coefficients does not
give the same model, since the estimates of the diagonal effects depend on the
estimates of these coefficients. For consistent interpretation of the covariate
coefficients, it is better to recode the gender role factors as follows:
\begin{alltt}
> MRMM2 <- as.numeric(!conformity$MRMM)
> FRMF2 <- as.numeric(!conformity$FRMF)
> A <- gnm(MCFM ~ -1 + AGEM + MRMM2 + FRMF2 + MWORK + MFCM +
+           Nonlin(Dref(MOPLM, FOPLF)), family = gaussian, data = conformity,
+           verbose = FALSE)
> A

Call:
gnm(formula = MCFM ~ -1 + AGEM + MRMM2 + FRMF2 + MWORK + MFCM +
    Nonlin(Dref(MOPLM, FOPLF)), family = gaussian, data = conformity,
    verbose = FALSE)


Coefficients:
                    AGEM                     MRMM2                     FRMF2
                 0.06364                   0.32425                   0.25324
                   MWORK                      MFCM  Dref(MOPLM, FOPLF).MOPLM
                -0.06430                  -0.06043                  -0.08270
Dref(MOPLM, FOPLF).FOPLF      Dref(MOPLM, FOPLF).1      Dref(MOPLM, FOPLF).2
                 0.22955                   4.37372                   4.28579
    Dref(MOPLM, FOPLF).3      Dref(MOPLM, FOPLF).4      Dref(MOPLM, FOPLF).5
                 4.28708                   4.14593                   3.85766
    Dref(MOPLM, FOPLF).6      Dref(MOPLM, FOPLF).7
                 3.61123                   3.85629

Deviance:            425.3389
Pearson chi-squared: 425.3389
Residual df:         576
\end{alltt}
The coefficients of the covariates are now as reported by \citet{Vand02}, but
the diagonal effects have been adjusted appropriately.

\citet{Vand02} compare the baseline model for the mother's conformity score to
several other models in which the weights in the diagonal reference term are
dependent on one of the covariates. One particular model they consider
incorporates an interaction of the weights with the mother's conflict score as
follows:
\[
\mu_{rc} = \beta_1x_1 + \beta_2x_2 + \beta_3x_3 +\beta_4x_4 +\beta_5x_5 +
\frac{e^{\xi_1 + \beta_1x}}{e^{\xi_1 + \beta_1x} +
e^{\xi_2 + \beta_2x}}\gamma_r + \frac{e^{\xi_2 + \beta_2x}}{e^{\xi_1 + \beta_1x}
+ e^{\xi_2 + \beta_2x}}\gamma_c.
\]

This model can be fitted as below, using the original coding for the gender
role factors for ease of comparison to the results reported by \citet{Vand02},
\begin{alltt}
> F <- gnm(MCFM ~ -1 + AGEM + MRMM + FRMF + MWORK + MFCM +
+           Nonlin(Dref(MOPLM, FOPLF, formula = ~ 1 + MFCM)), family = gaussian,
+           data = conformity, verbose = FALSE)
> F

Call:
gnm(formula = MCFM ~ -1 + AGEM + MRMM + FRMF + MWORK + MFCM +
    Nonlin(Dref(MOPLM, FOPLF, formula = ~1 + MFCM)), family = gaussian,
    data = conformity, verbose = FALSE)


Coefficients:
                                                     AGEM
                                                  0.05818
                                                     MRMM
                                                 -0.32701
                                                     FRMF
                                                 -0.25772
                                                    MWORK
                                                 -0.07847
                                                     MFCM
                                                 -0.01694
Dref(MOPLM, FOPLF, formula = ~1 + MFCM).MOPLM.(Intercept)
                                                  0.79413
       Dref(MOPLM, FOPLF, formula = ~1 + MFCM).MOPLM.MFCM
                                                 -2.51751
Dref(MOPLM, FOPLF, formula = ~1 + MFCM).FOPLF.(Intercept)
                                                 -0.27618
       Dref(MOPLM, FOPLF, formula = ~1 + MFCM).FOPLF.MFCM
                                                  2.03673
                Dref(MOPLM, FOPLF, formula = ~1 + MFCM).1
                                                  4.82477
                Dref(MOPLM, FOPLF, formula = ~1 + MFCM).2
                                                  4.88066
                Dref(MOPLM, FOPLF, formula = ~1 + MFCM).3
                                                  4.83969
                Dref(MOPLM, FOPLF, formula = ~1 + MFCM).4
                                                  4.74849
                Dref(MOPLM, FOPLF, formula = ~1 + MFCM).5
                                                  4.42019
                Dref(MOPLM, FOPLF, formula = ~1 + MFCM).6
                                                  4.17956
                Dref(MOPLM, FOPLF, formula = ~1 + MFCM).7
                                                  4.40819

Deviance:            420.9022
Pearson chi-squared: 420.9022
Residual df:         575
\end{alltt}
In this case there are two sets of weights, one for when the mother's conflict
score is less than average (coded as zero) and one for when the score is greater
than average (coded as one). These can be evaluated as follows:
\begin{alltt}
> prop.table(exp(coef(F))[c(6,8)])
Dref(MOPLM, FOPLF, formula = ~1 + MFCM).MOPLM.(Intercept)
                                                0.7446574
Dref(MOPLM, FOPLF, formula = ~1 + MFCM).FOPLF.(Intercept)
                                                0.2553426
> prop.table(exp(coef(F)[c(7,9)] + coef(F)[c(6,8)]))
Dref(MOPLM, FOPLF, formula = ~1 + MFCM).MOPLM.MFCM
                                        0.02977308
Dref(MOPLM, FOPLF, formula = ~1 + MFCM).FOPLF.MFCM
                                        0.97022692
\end{alltt}
giving the same weights as in Table 4 of \citet{Vand02}.

\subsection{Uniform Difference (UNIDIFF) Models}
\label{Unidiff}

Uniform difference models \citep{Xie92, Erik92} use a simplified three-way
interaction to provide an interpretable model of contingency tables classified
by three or more variables. For example, the uniform difference model for a
three-way contingency table, also known as the UNIDIFF model, is given by
\[
\mu_{ijk} = \alpha_{ik} + \beta_{jk} + \exp(\delta_k)\gamma_{ij}.
\]
The $\gamma_{ij}$ represent a pattern of association that varies in strength
over the dimension indexed by $k$, and $\exp(\delta_k)$ represents the relative
strength of that association at level $k$.

This model can be applied to the \Robject{yaish} data set
\citep{Yais98,Yais04},
which is a
contingency table cross-classified by father's social class (\Robject{orig}),
son's social
class (\Robject{dest}) and son's education level (\Robject{educ}).
In this case, we can consider the
importance of the association between the social class of father and son across
the education levels.  We omit the sub-table which corresponds to level 7 of
\Robject{dest}, because its information content is negligible:
@
<<UNIDIFF_model>>=
set.seed(1)
data(yaish)
unidiff <- gnm(Freq ~ educ*orig + educ*dest +
               Mult(Exp(-1 + educ), -1 + orig:dest), family = poisson,
               data = yaish, subset = (dest != 7))
coefs.of.interest <- grep("Mult1.Factor1", names(coef(unidiff)))
coef(unidiff)[coefs.of.interest]
@ %def
The \Robject{coefs.of.interest} are the multipliers of the association between
the social class of father and son. We can contrast each multiplier to that of
the lowest education level and obtain the standard errors for these parameters
as follows:
@
<<Unidiff_contrasts>>=
getContrasts(unidiff, coefs.of.interest)
@ %def

Four-way contingency tables may sometimes be described by a
``double UNIDIFF'' model
\[
\mu_{ijkl} = \alpha_{il} + \beta_{jkl} + \exp(\delta_l)\gamma_{ij} +
\exp(\phi_l)\theta_{ik},
\]
where the strengths of two, two-way associations with a common variable are
estimated across the levels of the fourth variable.
The \Robject{cautres} data set, from \citet{Caut98}, can be used to illustrate
the application of the
double UNIDIFF model. This data set is classified by the variables vote, class,
religion and election. Using a double UNIDIFF model, we can see how the
association between class and vote, and the association between religion and
vote, differ between the most recent election and the other elections:
@
<<double_UNIDIFF_model>>=
set.seed(1)
data(cautres)
doubleUnidiff <- gnm(Freq ~ election*vote + election*class*religion +
                     Mult(Exp(-1 + election), religion:vote) +
                     Mult(Exp(-1 + election), class:vote),
                     family = poisson, data = cautres)
getContrasts(doubleUnidiff,
             rev(grep("Mult1.Factor1", names(coef(doubleUnidiff)))))
getContrasts(doubleUnidiff,
             rev(grep("Mult2.Factor1", names(coef(doubleUnidiff)))))
@ %def

\subsection{Generalized Additive Main Effects and
Multiplicative Interaction (GAMMI) Models}
\label{GAMMI}

Generalized additive main effects and multiplicative interaction models, or
GAMMI models, were motivated by two-way contingency tables and comprise the row
and column main effects plus one or more components of the multiplicative
interaction. The singular value corresponding to each multiplicative component
is often factored out, as a measure of the strength of association between the
row and column scores, indicating the importance of the component, or axis.

For cell means $\mu_{rc}$ a GAMMI-K model has the form
\[
g(\mu_{rc}) = \alpha_r + \beta_c + \sum_{k=1}^K
\sigma_k\gamma_{kr}\delta_{kc},
\]
in which $g$ is a link function, $\alpha_r$ and $\beta_c$ are the row and column
main effects, $\gamma_{kr}$ and $\delta_{kc}$ are the row and column scores for
multiplicative component $k$ and $\sigma_k$ is the singular value for component
$k$. The number of multiplicative components, $K$, is less than or equal to the
rank of the matrix of residuals from the main effects.

The row-column association models discussed in Section \ref{RCmodels} are
examples of GAMMI models, with a log link and poisson variance. Here we
illustrate the use of an AMMI model, which is a GAMMI model with an identity
link and a constant variance.

We shall use the \Robject{wheat} data set taken from \citet{Varg01}, which gives
wheat yields measured over ten years. First we scale these yields and
create a new treatment factor, so that we can reproduce the analysis of
\citet{Varg01}:
@
<<Scale_yields>>=
set.seed(1)
data(wheat)
yield.scaled <- wheat$yield * sqrt(3/1000)
treatment <- interaction(wheat$tillage, wheat$summerCrop, wheat$manure,
                         wheat$N, sep = "")
@ %def
Now we can fit the AMMI-1 model, to the scaled yields using the combined
treatment factor and the year factor from the \Robject{wheat} dataset:
@
<<AMMI_model>>=
bilinear1 <- gnm(yield.scaled ~ year + treatment + Mult(year, treatment),
                 family = gaussian, data = wheat)
@ %def
and compare the AMMI-1 model to the main effects model
@
<<AOD>>=
mainEffects <- glm(yield.scaled ~ year + treatment, family = gaussian,
                   data = wheat)
anova(mainEffects, bilinear1)
@ %def
giving the same results as in Table 1 of \citet{Varg01} (up to error caused by
rounding).

\subsection{Biplot Models}
\label{biplot}

Biplots are used to display two-dimensional data transformed into a space
spanned by linearly independent vectors, such as the principal components or
singular vectors. The plot represents the levels of the two classifying
factors by
their scores on the two axes which show the most information about the data, for
example the first two principal components.

A rank-$n$ model is a model based on the first $n$ components of the
decomposition. In the case of a singular value decomposition, this is equivalent
to a model with $n$ components of the multiplicative interaction.

To illustrate the use of biplot models, we shall use the \Robject{barley} data
set which describes the incidence of leaf blotch over ten varieties of barley
grown at nine sites \citep{Wedd74,Gabr98}. The biplot model is fitted as
follows:
@
<<Biplot_model>>=
data(barley)
set.seed(1)
biplotModel <- gnm(y ~ -1 + Mult(site, variety, multiplicity = 2),
                   family = wedderburn, data = barley)
@ %def
using the \Rfunction{wedderburn} family function introduced in Section
\ref{glms}. Matrices of the row and column scores for the first two singular
vectors can then be obtained by:
@
<<Row_and_column_scores>>=
barleySVD <- svd(matrix(biplotModel$predictors, 10, 9))
A <- sweep(barleySVD$v, 2, sqrt(barleySVD$d), "*")[, 1:2]
B <- sweep(barleySVD$u, 2, sqrt(barleySVD$d), "*")[, 1:2]
A
B
@ %def
These matrices are essentially the same as in \citet{Gabr98}. From these the
biplot can be produced, for sites $A \ldots I$ and varieties $1 \dots 9, X$:
\begin{center}
@
<<Biplot, fig = TRUE>>=
plot(rbind(A, B), pch = c(levels(barley$site), levels(barley$variety)),
     xlim = c(-4, 4), ylim = c(-4, 4), main = "Biplot for barley data")
@ %Def
\end{center}
The product of the matrices
\Robject{A} and \Robject{B}
is unaffected by rotation or reciprocal scaling along either axis,
so we can rotate the data so that the points for the sites are roughly parallel
to the horizontal axis and the points for the varieties are roughly parallel to
the vertical axis. In addition, we can scale the data so that points for the
sites are about the line one unit about the horizontal axis, roughly
\begin{center}
@
<<Rotate_and_scale, fig = TRUE>>=
a <- pi/5
rotation <- matrix(c(cos(a), sin(a), -sin(a), cos(a)), 2, 2, byrow = TRUE)
rA <- (2 * A/3) %*% rotation
rB <- (3 * B/2) %*% rotation
plot(rbind(rA, rB), pch = c(levels(barley$site), levels(barley$variety)),
     xlim = c(-4, 4), ylim = c(-4, 4),
     main = "Biplot (rotated) for barley data")
@ %def
\end{center}
In the original biplot, the co-ordinates for the sites and varieties were given
by the rows of A and B respectively, i.e
\begin{eqnarray*}
\alpha_i^T &= \sqrt(d)(u_{1i}, u_{2i})\\
\beta_j^T &= \sqrt(d)(v_{1j}, v_{2j})
\end{eqnarray*}
The rotated and scaled biplot suggests the simpler model
\begin{eqnarray*}
\alpha_i^T &= (\gamma_i, 1) \\
\beta_j^T &= (\delta_j, \tau_j)
\end{eqnarray*}
which implies the following model for the logits of the leaf blotch incidence:
\[\alpha_i^T\beta_j = \gamma_i\delta_j + \tau_j.\]
\citet{Gabr98} describes this as a double additive model, which we can fit as
follows:
@
<<Double_additive>>=
variety.binary <- factor(match(barley$variety, c(2,3,6), nomatch = 0) > 0,
                        labels = c("rest", "2,3,6"))
doubleAdditive <- gnm(y ~ variety + Mult(site, variety.binary),
                      family = wedderburn, data = barley)
@ %def
Comparing the chi-squared statistics, we see that the double additive model is
an adequate model for the leaf blotch incidence:
@
<<Compare_chi-squared>>=
biplotModChiSq <- sum(residuals(biplotModel, type = "pearson")^2)
doubleAddChiSq <- sum(residuals(doubleAdditive, type = "pearson")^2)
c(doubleAddChiSq - biplotModChiSq,
  doubleAdditive$df.residual - biplotModel$df.residual)
@ %def

\subsection{Stereotype Model}
\label{Stereotype}

The stereotype model was proposed by \citet{Ande84} for ordered categorical
data. It is a linear logistic model, in which there is assumed to be a common
relationship between the response and the covariates in the model, but the
scale of this association varies between categories and there is an additional
category main effect or category-specific intercept:
\[
\log \mu_{ic} =  \beta_{0c} + \gamma_c\sum_r
\boldsymbol{\beta}_{r}\boldsymbol{x}_{ir}.
\]
This model can be estimated by re-expressing the categorical data as counts and
using a \Rclass{gnm} model with a log link and poisson variance function. The
\Rpackage{gnm} package includes the utility function
\Rfunction{expandCategorical} to facilitate the required data processing.

For example, the \Robject{backPain} data set from \citet{Ande84} describes the
progress of patients with back pain. The data set consists of an ordered factor
quantifying the progress of each patient, and three prognostic variables. These
data can be re-expressed as follows:
@
<<Re-express_data>>=
set.seed(1)
data(backPain)
backPain[1:2,]
backPainLong <- expandCategorical(backPain, "pain")
backPainLong[1:12,]
@ %def
We can now fit the stereotype model to these data:
@
<<Stereotype_model>>=
oneDimensional <- gnm(count ~ pain + Mult(pain - 1, x1 + x2 + x3 - 1),
                      eliminate = id, family = "poisson", data = backPainLong)
oneDimensional
@ %def
using \Rfunarg{eliminate} to handle the \Robject{id} factor so that these
structural parameters do not appear in the model summaries. This model is one
dimensional since it involves only one function of $\mathbf{x} = (x1, x2,
x3)$. We can compare this model to one with category-specific coefficents of the
$x$ variables, as may be used for a qualitative categorical response:
@
<<Qualitative_model>>=
threeDimensional  <- gnm(count ~ pain + pain:(x1 + x2 + x3), eliminate = id,
                         family = "poisson", data = backPainLong)
threeDimensional
@ %def
This model has the maximum dimensionality of three (as determined by the number
of covariates). To obtain the log-likelihoods as reported in \citet{Ande84} we
need to adjust for the extra parameters introduced to formulate the models as
Poisson models. We write a simple function to do this and compare the
log-likelihoods of the one dimensional model and the three dimensional model:
@
<<Calculate_log-likelihood>>=
logLikMultinom <- function(model){
    object <- get(model)
    if (inherits(object, "gnm")) {
        l <- logLik(object) + object$eliminate
        c(nParameters = attr(l, "df") - object$eliminate, logLikelihood = l)
    }
    else
        c(nParameters = object$edf, logLikelihood = -deviance(object)/2)
}
t(sapply(c("oneDimensional", "threeDimensional"), logLikMultinom))
@ %def
which show that the \Robject{oneDimensional} model is adequate.

To obtain estimates of the category-specific multipliers in the stereotype
model, we need to constrain both the location and the scale of these
parameters. The latter constraint can be imposed by fixing the slope of one of
the covariates in the second multiplier to \Robject{1}, which may be achieved by
specifying the covariate as an offset:
@
<<constrain_slopes>>=
## before constraint
summary(oneDimensional)
oneDimensional <- gnm(count ~ pain + Mult(pain - 1, offset(x1) + x2 + x3 - 1),
                      eliminate = id, family = "poisson", data = backPainLong)
## after constraint
summary(oneDimensional)
@ %def
The location of the category-specific multipliers can constrained by setting one
of the parameters to zero, either through the \Rfunarg{constrain} argument of
\Rfunction{gnm} or with \Rfunction{getContrasts}:
@
<<get_slopes>>=
getContrasts(oneDimensional, 6:11)
@ %def
giving the required estimates.

\newpage
\appendix

\section{User-level Functions}

We list here, for easy reference, all of the user-level functions in the
\Rpackage{gnm} package.  For full documentation see the package help pages.

\begin{table}[!h]
\begin{tabular*}{\textwidth}{@{}p{0.2in}p{1.3in}p{4.5in}@{}}
    \toprule
    \multicolumn{3}{l}{\textbf{Model Fitting}} 	\\
    \midrule
    &	\Rfunction{gnm}	&  fit generalized nonlinear models	\\
    \midrule
    \multicolumn{3}{l}{\textbf{Model Specification}}			\\
    \midrule
    &	\Rfunction{Diag}	&  create factor differentiating
                                   diagonal elements \\
    &	\Rfunction{Symm}	&  create symmetric interaction of factors \\
    &   \Rfunction{Topo}        &  create `topological' interaction factors \\
    &	\Rfunction{Mult}	&  specify a multiplicative interaction in a
                                   \Rfunction{gnm} formula	\\
    &	\Rfunction{Exp}	&  specify an exponentiated constituent multiplier in a
                           \Rfunction{Mult} term	\\
    &	\Rfunction{Nonlin}	&  specify a special nonlinear term in a
                                   \Rfunction{gnm} formula	\\
    &	\Rfunction{Dref}	&  gnm plug-in function to fit diagonal
                                   reference terms \\
    &	\Rfunction{MultHomog}	&  gnm plug-in function to fit multiplicative
                                   interactions with homogeneous effects	\\
    &   \Rfunction{wedderburn}      &  specify the Wedderburn
                                       quasi-likelihood family \\
    \midrule
    \multicolumn{3}{l}{\textbf{Methods and Accessor Functions}}	\\
    \midrule
    &	\Rmethod{summary.gnm}	&  summarize \Rclass{gnm} fits	\\
    &	\Rfunction{getContrasts}	&  estimate contrasts and their
                                           standard errors for parameters in a gnm
                                           model \\
    &	\Rfunction{checkEstimable}	&  check whether one or more parameter
                                           combinations in a
                                           \Rclass{gnm} model is identified \\
    &	\Rfunction{residSVD}	&  multiplicative approximation of
                                   model residuals	\\
    &	\Rfunction{se}	&  get standard errors of linear parameter
                           combinations in \Rclass{gnm} models	\\
    &	\Rfunction{termPredictors}	&  (\emph{generic}) extract term
                                           contributions to predictor	\\
    \midrule
    \multicolumn{3}{l}{\textbf{Auxiliary Functions}}			\\
    \midrule
    &	\Rfunction{getModelFrame}	&  get the model frame in use by
                                           \Rfunction{gnm}	\\
    &	\Rfunction{MPinv}	&  Moore-Penrose pseudoinverse of a
                                   real-valued matrix	\\
    &	\Rfunction{qrSolve}	&  Minimum-length solution of a linear system\\
    &   \Rfunction{expandCategorical}   & expand a data frame by re-expressing
                                          categorical data as counts \\
\end{tabular*}
\end{table}

\newpage
\section{Key Changes since Last Release}

The new features, improvements and changes in behaviour since the last release
are given below. For bug fixes since the last release and the changes made in
previous releases, see the CHANGES file in the \texttt{inst} directory of
the package.

\begin{verbatimtab}
New Features
------------

    o	added the `method' argument to MPinv(), to allow the method of
	calculation to be specified.  Permitted values are "svd" to
	compute the pseudo-inverse by singular value decomposition,
	and "chol" to use the Cholseky decomposition instead.  The latter
	is valid only for symmetric matrices, but is usually faster
    	and more accurate.

    o	added the `lsMethod' argument to gnm(), to allow specification of
	the numerical method used for least-squares calculations in the
	core of the iterative algorithm.  Permitted options are "svd",
	"chol" and "qr".

    o	added new function qrSolve(), which behaves like base::qr.coef but
        in the non-full-rank case gives the minimum-length solution rather
        than an arbitrary solution determined by pivoting.

Improvements
------------

    o	gnm() now takes less time to run due to improvements made in the
	iterative algorithm.
\end{verbatimtab}

\newpage
\bibliography{gnm}
\bibliographystyle{chicago}

\end{document}
